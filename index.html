<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BC Treasury</title>
  <style>
    /* Simple modern styling */
    :root{--bg:#0f1724;--card:#0b1220;--accent:#7dd3fc;--muted:#9ca3af;--glass: rgba(255,255,255,0.03)}
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,'Segoe UI',Roboto,'Helvetica Neue',Arial}
    body{background:linear-gradient(180deg,#071025 0%, #051027 60%);color:#e6eef8;padding:24px}
    .wrap{max-width:1200px;margin:0 auto}
    header{display:flex;align-items:center;justify-content:space-between;margin-bottom:18px}
    h1{font-size:20px;margin:0}
    .sub{color:var(--muted);font-size:13px}
    .grid{display:grid;grid-template-columns:380px 1fr;gap:18px}
    .card{background:var(--card);padding:14px;border-radius:12px;box-shadow:0 6px 30px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.02)}
    .small{font-size:13px;color:var(--muted)}
    .balance{font-weight:700;font-size:18px}
    .btn{background:linear-gradient(90deg,var(--accent),#60a5fa);border:none;padding:8px 12px;border-radius:8px;color:#012;cursor:pointer;font-weight:700}
    .mutebtn{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:6px 10px;border-radius:8px}
    .auction-timer{font-weight:800;font-size:18px}
    .list{margin-top:12px;display:flex;flex-direction:column;gap:10px}
    .bond{background:var(--glass);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);display:flex;justify-content:space-between;align-items:center}
    label{display:block;font-size:13px;margin-bottom:6px}
    input[type=number], input[type=text], select{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    .log{height:180px;overflow:auto;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
    table{width:100%;border-collapse:collapse}
    th,td{padding:6px;text-align:left;font-size:13px}
    th{color:var(--muted);font-weight:600}
    .mini{font-size:12px;color:var(--muted)}
    .controls{display:flex;gap:8px;align-items:center}
    .bots{display:flex;gap:8px;flex-wrap:wrap}
    .chip{padding:6px 8px;background:rgba(255,255,255,0.03);border-radius:999px;border:1px solid rgba(255,255,255,0.02);font-size:12px}
    footer{margin-top:14px;color:var(--muted);font-size:12px}
    .progress{height:8px;background:rgba(255,255,255,0.03);border-radius:999px;overflow:hidden}
    .progress > span{display:block;height:100%;background:linear-gradient(90deg,#22c55e,#7dd3fc)}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>BC Treasury</h1>
        <div class="sub"> Made by James Degenhardt, B-07, BC</div>
      </div>
      <div class="controls">
        <div class="mini"></div>
        <label style="display:flex;align-items:center;gap:8px"><input id="fastMode" type="checkbox"></label>
        <button id="resetBtn" class="mutebtn"></button>
      </div>
    </header>

    <div class="grid">
      <aside class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div class="small">N/A</div>
            <div class="balance" id="balanceDisplay">$1,000.00</div>
            <div class="small">Portfolio value: <span id="portfolioValue">$0.00</span></div>
          </div>
          <div style="text-align:right">
            <div class="small"></div>
            <div class="auction-timer" id="auctionTimer">--:--</div>
            <div class="small">Phase: <span id="auctionPhase">Waiting</span></div>
          </div>
        </div>

        <hr style="border:none;height:1px;background:rgba(255,255,255,0.03);margin:12px 0">

        <div>
          <div class="small">Place Bid</div>
          <label>Bid price (per 100 face): <input id="bidPrice" type="number" step="0.01" value="99.50"></label>
          <label>Quantity (face value): <input id="bidQty" type="number" step="100" value="1000"></label>
          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="placeBidBtn" class="btn">Place Bid</button>
            <button id="clearBidsBtn" class="mutebtn">Clear My Bids</button>
          </div>
        </div>

        <hr style="border:none;height:1px;background:rgba(255,255,255,0.03);margin:12px 0">
        <div>
          <div class="small">Active Bonds (in portfolio)</div>
          <div id="portfolioList" class="list" style="max-height:220px;overflow:auto"></div>
        </div>

      </aside>

      <main>
        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div>
              <div style="font-weight:800">Live Auctions</div>
              <div class="mini"></div>
            </div>
            <div style="text-align:right">
              <div class="mini">Auction size (face): <strong id="auctionSize">100,000</strong></div>
              <div class="mini">Next auction starts on schedule</div>
            </div>
          </div>

          <hr style="border:none;height:1px;background:rgba(255,255,255,0.03);margin:12px 0">

          <div style="display:flex;gap:12px">
            <div style="flex:1">
              <div class="small">Current Bond</div>
              <div id="currentBond" style="margin-top:8px"></div>
            </div>
            <div style="width:320px">
              <div class="small">Auction Book</div>
              <div id="auctionBook" style="margin-top:8px;max-height:220px;overflow:auto"></div>
            </div>
          </div>

          <div style="margin-top:12px">
            <div class="small">Recent Events</div>
            <div id="eventLog" class="log"></div>
          </div>
        </div>

        <div style="height:12px"></div>

        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div><strong>Market History</strong> <div class="mini">Last auctions</div></div>
            <div class="mini">All bonds auctioned on BC Treasury are non-marketable securities</div>
          </div>
          <div style="margin-top:8px">
            <table id="historyTable"><thead><tr><th>Time</th><th>Bond ID</th><th>Maturity (yrs)</th><th>Avg Price</th><th>Yield (%)</th><th>Qty Issued</th></tr></thead><tbody></tbody></table>
          </div>
        </div>

      </main>
    </div>

    <footer>
       <strong></strong> ©2025
    </footer>
  </div>

<script>
/* Bond auction single-file game logic */
(function(){
  // --- Game state ---
const STORAGE_KEY = 'BC_TREASURY_SAVE_V1';

const state = {
  balance: 1_000,
  portfolio: [],
  nextBondId: 1,
  auctionCycleMs: 5 * 60 * 1000,     // 5 minutes cycle
  auctionDurationMs: 3 * 60 * 1000,  // 3 minutes open
  fastMode: false,
  auctionTimerHandle: null,
  auctionPhase: 'waiting',
  currentAuction: null,
  auctionHistory: []
};

// ms per game-year (normal = real year; fastMode compressed for testing)
function msPerGameYear() {
  return state.fastMode ? 60 * 1000 : 365 * 24 * 60 * 60 * 1000;
}


// DOM
  const balanceDisplay = document.getElementById('balanceDisplay');
  const portfolioValueEl = document.getElementById('portfolioValue');
  const auctionTimer = document.getElementById('auctionTimer');
  const auctionPhaseEl = document.getElementById('auctionPhase');
  const currentBondEl = document.getElementById('currentBond');
  const auctionBookEl = document.getElementById('auctionBook');
  const eventLog = document.getElementById('eventLog');
  const historyTableBody = document.querySelector('#historyTable tbody');
  const balanceFmt = v => '$' + v.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});

  // Controls
  const bidPriceInput = document.getElementById('bidPrice');
  const bidQtyInput = document.getElementById('bidQty');
  const placeBidBtn = document.getElementById('placeBidBtn');
  const clearBidsBtn = document.getElementById('clearBidsBtn');
  const resetBtn = document.getElementById('resetBtn');
  const fastModeChk = document.getElementById('fastMode');
  const auctionSizeEl = document.getElementById('auctionSize');

  function logEvent(txt){
    const p = document.createElement('div'); p.textContent = `[${new Date().toLocaleTimeString()}] ${txt}`;
    eventLog.prepend(p);
  }

  // -------------------------
  // deterministic PRNG helper for generating identical auctions across devices
  // seed: number (e.g., cycleStart millis)
  function mulberry32(a) {
    return function() {
      a |= 0; a = a + 0x6D2B79F5 | 0;
      var t = Math.imul(a ^ a >>> 15, 1 | a);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
  }

  // -------------------------
  // getAuctionTimes: compute UTC-aligned cycle boundaries
  function getAuctionTimes(ts = Date.now()) {
    const now = ts;
    const cycle = state.auctionCycleMs;
    const dur = state.auctionDurationMs;

    // Align to absolute UTC cycle boundary
    const cycleStart = now - (now % cycle);
    const auctionStart = cycleStart;
    const auctionEnd = cycleStart + dur;
    const nextCycleStart = cycleStart + cycle;

    return {
      auctionStart,
      auctionEnd,
      nextCycleStart,
      cycleStart
    };
  }

  // --- Bond generation (changed slightly to allow deterministic generation when a seed is provided)
  function generateBond(seed = null){
    // Each bond has: id, couponRate (annual %), maturityMinutes, issuanceFace, description
    // If seed is provided, use deterministic values so all clients see identical bond
    const id = Math.floor(seed / state.auctionCycleMs);
    let rnd = Math.random;
    if(seed !== null){
      rnd = mulberry32(Number(seed & 0xffffffff));
    }
    // Randomize coupon between 0.25% and 8% (annual)
    const coupon = +( (rnd() * 7.75 + 0.25).toFixed(3) );
    // Randomize maturity between 1 year and 30 years
    // Randomize maturity between 1 minute and 1440 minutes (24 hours)
const maturityMinutes = Math.floor(rnd() * 60) + 1; // 1..1440 minutes

    // issuance size:
const issuance = 100_000; // face amount available in auction

// Convert minutes to years
const maturityYears = maturityMinutes / 525600; // 525,600 minutes per year

const bond = {
  id: `B-${id}`,
  couponRate: coupon, // annual %
  maturityMinutes: maturityMinutes,
  maturityYears: maturityYears,   // now properly defined
  issuanceFace: issuance,
  description: `${maturityMinutes}-minute Treasury-like bond @ ${coupon}% coupon`
};


    return bond;
  }

  // --- Auction model ---
  // startNewAuction creates an auction. When called from UTC sync we pass cycleStart as seed so bond is deterministic.
  function startNewAuction(cycleStart){
  const bond = generateBond(cycleStart);

const rnd = mulberry32(cycleStart & 0xffffffff);

  const minPrice = +(90 + rnd() * 10).toFixed(2); // 90.00–100.00

  state.currentAuction = {
    bond,
    bids: [],
    minPrice,
    createdAt: cycleStart,
    startsAt: cycleStart,
    endsAt: cycleStart + state.auctionDurationMs,
    cycleStart
  };

  auctionPhaseEl.textContent = 'open';
  state.auctionPhase = 'open';
  logEvent(`Auction opened: ${bond.id}`);
}


  // closeAuction unchanged logic (keeps allocation rules)
  function closeAuction(auction){
    if(!state.currentAuction || auction !== state.currentAuction) return;
    state.auctionPhase = 'settling';
    auctionPhaseEl.textContent = 'settling';
    // compute average price weighted by qty
    const bids = auction.bids;
    if(bids.length === 0){
      logEvent(`Auction ${auction.bond.id} closed with no bids — bond unsold.`);
      state.auctionHistory.unshift({time: new Date(), bond:auction.bond, avgPrice:null, yield:null, issued:0, cycleStart: auction.cycleStart});
      renderHistory();
      state.currentAuction = null;
      // schedule next auction at cycle boundary (UTC-driven)
      return;
    }
    const minAllowed = auction.minPrice;
const validBids = bids.filter(b => (b.pricePer100 >= minAllowed) && (b.isValid !== false));

// filter valid bids (defensive)

if(validBids.length === 0){
  logEvent(`Auction ${auction.bond.id} `);
  state.auctionHistory.unshift({
    time: new Date(),
    bond: auction.bond,
    avgPrice: null,
    yield: null,
    issued: 0,
    cycleStart: auction.cycleStart
  });
  state.currentAuction = null;
  return;
}

// clearing price = lowest bid
const clearingPrice = Math.min(...validBids.map(b => b.pricePer100));
const avgPrice = +clearingPrice.toFixed(4); // reuse variable name
// per 100 face
    // compute simple annual yield approximation: (coupon + (100 - price)/yrs) / ((100+price)/2)
    const yrs = auction.bond.maturityYears;
    const coupon = auction.bond.couponRate;
    const yieldAnnual = +(
  (
    coupon +
    (100 - avgPrice) / yrs
  ) /
  avgPrice * 100
).toFixed(4);

    // allocation: issuance divided proportionally across bidders
    const issuance = auction.bond.issuanceFace;
    const allocations = bids.map(b=>({who:b.who, qtyAllocated: Math.floor(b.qtyFace/100)})); // in lots of 100 face
    // total lots requested
    const totalLotsRequested = bids.reduce((s,b)=>s + Math.floor(b.qtyFace/100),0);
    const lotsToIssue = issuance/100;
    // determine allocations
    let resolved = [];
    if(totalLotsRequested <= 0){
      // no real requests
    }
    if(totalLotsRequested <= lotsToIssue){
      // everyone gets full
      bids.forEach(b=>{
        const lots = Math.floor(b.qtyFace/100);
        const assignedFace = lots*100;
        resolved.push({...b, assignedFace});
      });
    } else {
      // pro-rata by quantity
      bids.forEach(b=>{
        const lots = Math.floor(b.qtyFace/100);
        const fraction = lots/totalLotsRequested;
        const assignedLots = Math.floor(fraction * lotsToIssue);
        resolved.push({...b, assignedFace: assignedLots*100});
      });
      // If rounding left some lots, give them to highest price bids
      let allocatedLots = resolved.reduce((s,r)=>s + (r.assignedFace/100), 0);
      let remainingLots = lotsToIssue - allocatedLots;
      if(remainingLots>0){
        // sort by price desc
        const byPrice = resolved.slice().sort((a,b)=>b.pricePer100-a.pricePer100);
        for(let r of byPrice){ if(remainingLots<=0) break; r.assignedFace += 100; remainingLots--; }
      }
    }

    // settle: charge players and bots receive allocations (bots ignored). Player may have multiple bids; process any entries with who === 'player'
    const playerBids = resolved.filter(r => r.who === 'player' && r.assignedFace > 0);

    const playerTotalAssigned = playerBids.reduce((s,r)=>s + r.assignedFace,0);
    const playerCost = playerTotalAssigned/100 * avgPrice; // per 100 face
    // convert to actual dollars: price per 100 face times number of lots (face/100)
    const playerCostDollars = playerCost * 1; // since price is per 100 face representing dollars per 100 face
    // But to make units consistent: We interpret pricePer100 as dollars per 100 face. So cost = (assignedFace/100)*pricePer100
    let actualPlayerCost = 0;
    playerBids.forEach(b=>{ actualPlayerCost += (b.assignedFace/100) * avgPrice; });

    // Deduct from balance and add portfolio entries
    if(actualPlayerCost>0){
      if(actualPlayerCost > state.balance){
        // can't pay: reduce allocation to zero and log
        logEvent(`Player allocation for ${auction.bond.id} exceeded balance — allocation canceled.`);
      } else {
        state.balance -= actualPlayerCost;
        // add bond to portfolio as a position with assignedFace and purchase price
      const now = Date.now();
const maturityMs = auction.bond.maturityMinutes * 60 * 1000;

const pos = {
  id: auction.bond.id,
  couponRate: auction.bond.couponRate,
  maturityYears: auction.bond.maturityYears,
  face: playerTotalAssigned,
  pricePer100: avgPrice,
  purchaseTime: now,
  maturityTime: now + maturityMs,
  yield: yieldAnnual
};

state.portfolio.push(pos);

// save immediately after purchase
saveState();

        logEvent(`Auction ${auction.bond.id} settled: avgPrice=$${avgPrice} | yield=${yieldAnnual}% | you received ${playerTotalAssigned.toLocaleString()} face for $${actualPlayerCost.toFixed(2)}`);
      }
    } else {
      logEvent(`Auction ${auction.bond.id} settled: avgPrice=$${avgPrice} | yield=${yieldAnnual}% | you did not receive allocation.`);
    }

    // record to history
    state.auctionHistory.unshift({time: new Date(), bond:auction.bond, avgPrice, yield: yieldAnnual, issued: issuance, cycleStart: auction.cycleStart});
    // persist
    saveState();

    renderHistory();
    renderPortfolio();
    renderBalance();

    // cleanup
    state.currentAuction = null;
    // schedule next auction per UTC schedule
  }

  // scheduleNextAuction: align with UTC cycle boundary (keeps compatibility with earlier code paths)
  
  // --- Bots ---
  const botNames = ['Eshaan','Trever','Ryan R','John B','Epsilon','Francis','Adam R','Tom','Jackson D','Alex D','Dylan','Shriman','Daniel L','Lily','Phill','Juan','Anna','Samuel','Mallary','Jaob','Matthew','Allison','Evan','Kaylee','Brooke','Luke','Zoe','Luis','Brian','Alexa','Owen','Sfia','Landon','Julian','Vanessa','Xavier','Maya','Blake','Hayden','Jeremy','Marcus','Amy','Martin','Karina','Marco','Ellie','Leanardo','Liliana'];
  function simulateBotsDuringAuction(){
    if(!state.currentAuction) return;
    const auction = state.currentAuction;
    // every 5-15 seconds (or scaled) bots place bids
    const intervalMs = state.fastMode ? 1500 : 8000;
    const rounds = state.fastMode ? 6 : Math.max(8, Math.floor(state.auctionDurationMs/intervalMs));
    for(let i=0;i<rounds;i++){
      setTimeout(()=>{
        if(!state.currentAuction || state.currentAuction !== auction) return;
        // each round, a few random bots bid
        const n = Math.floor(Math.random()*3)+1;
        for(let j=0;j<n;j++){
          const bot = botNames[Math.floor(Math.random()*botNames.length)];
          // bot chooses price around a range depending on coupon: aim near 100
          const coupon = auction.bond.couponRate;
         let price = +(90 + Math.random() * 10).toFixed(2); // random 90.00–100.00


          const qty = (Math.floor(Math.random()*40)+1)*100; // lots of 100
          auction.bids.push({who:bot, pricePer100:price, qtyFace:qty});
        }
        renderAuctionBook();
      }, i*intervalMs + Math.random()*1000);
    }
  }

  // Player interactions
  function placePlayerBid(){
  if(!state.currentAuction){ alert('No active auction.'); return; }
  const price = parseFloat(bidPriceInput.value);
  const qty = parseInt(bidQtyInput.value);
  if(isNaN(price) || isNaN(qty) || price<=0 || qty<=0){ alert('Enter valid bid and quantity.'); return; }

  // store bid anyway, visually
  state.currentAuction.bids.push({who:'player', pricePer100:+price, qtyFace:qty, isValid: price >= state.currentAuction.minPrice});

  // log event differently if invalid
  if(price < state.currentAuction.minPrice){
    logEvent(`You placed bid: $${price.toFixed(2)} per 100 | qty ${qty.toLocaleString()} `);
  } else {
    logEvent(`You placed bid: $${price.toFixed(2)} per 100 | qty ${qty.toLocaleString()}`);
  }

  renderAuctionBook();
  saveState();
}


  function clearPlayerBids(){
    if(!state.currentAuction) return;
    state.currentAuction.bids = state.currentAuction.bids.filter(b=>b.who !== 'player');
    logEvent('Cleared your bids for current auction.');
    renderAuctionBook();
    saveState();
  }

  // -------------------------
  // Persistence: save/load using localStorage
 function saveState(){
  try{
    const serial = JSON.stringify({
      balance: state.balance,
      portfolio: state.portfolio,
      nextBondId: state.nextBondId,
      auctionHistory: state.auctionHistory,
      currentAuction: sanitizeAuctionForSave(state.currentAuction), // <-- add this
    });
    localStorage.setItem(STORAGE_KEY, serial);
  }catch(e){
    console.warn('Save failed', e);
  }
}


  function sanitizeAuctionForSave(auction){
    if(!auction) return null;
    // Save minimal auction state so we can resume (bids, bond, endsAt, cycleStart)
    return {
      bond: auction.bond,
      bids: auction.bids,
      createdAt: auction.createdAt,
      startsAt: auction.startsAt,
      endsAt: auction.endsAt,
      cycleStart: auction.cycleStart
    };
  }

  function loadState(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return;
      const obj = JSON.parse(raw);
      if(obj.balance!=null) state.balance = obj.balance;
      if(Array.isArray(obj.portfolio)) state.portfolio = obj.portfolio.map(p=>{
        // defensive: ensure numbers are numbers
        p.purchaseTime = Number(p.purchaseTime);
        p.maturityTime = Number(p.maturityTime);
        return p;
      });
      if(obj.nextBondId!=null) state.nextBondId = obj.nextBondId;
      if(Array.isArray(obj.auctionHistory)) state.auctionHistory = obj.auctionHistory;
      if(obj.currentAuction){
        const ca = obj.currentAuction;
        // if saved auction still active, resume it
        if(typeof ca.endsAt === 'number' && Date.now() < ca.endsAt){
          state.currentAuction = {
            bond: ca.bond,
            bids: ca.bids || [],
            createdAt: ca.createdAt || Date.now(),
            startsAt: ca.startsAt || Date.now(),
            endsAt: ca.endsAt,
            cycleStart: ca.cycleStart || null
          };
          state.auctionPhase = 'open';
        } else {
          // expired: ignore and let schedule start next
          state.currentAuction = null;
        }
      }
    }catch(e){
      console.warn('Load failed', e);
    }
  }

  // -------------------------
  // Rendering functions
  function renderBalance(){ balanceDisplay.textContent = balanceFmt(state.balance); }
  function renderAuctionBook(){
    auctionBookEl.innerHTML = '';
    if(!state.currentAuction){ auctionBookEl.textContent = 'No active auction.'; return; }
    const grouped = {};
    state.currentAuction.bids.slice().reverse().forEach(b=>{
      const div = document.createElement('div'); div.className='bond';
      div.innerHTML = `<div style="flex:1"><div style='font-weight:700'>${b.who}</div><div class='mini'>qty ${b.qtyFace.toLocaleString()} face</div></div><div style='text-align:right'><div style='font-weight:800'>$${b.pricePer100}</div></div>`;
      auctionBookEl.appendChild(div);
    });
  }
  function renderCurrentBond(){
    currentBondEl.innerHTML = '';
    if(!state.currentAuction){ currentBondEl.textContent = 'No live bond right now. An auction will open on schedule.'; return; }
    const b = state.currentAuction.bond;
const box = document.createElement('div'); 
box.className = 'bond';

box.innerHTML = `
  <div style='flex:1'>
    <div style='font-weight:800'>${b.id} — ${b.couponRate}% coupon</div>
    <div class='mini'>${b.description}</div>
    <div class='mini'>Maturity: ${b.maturityYears} years</div>
  </div>
  <div style='text-align:right'>
    <div class='mini'>Issuance</div>
    <div style='font-weight:800'>${b.issuanceFace.toLocaleString()} face</div>
  </div>
  
`;

currentBondEl.appendChild(box);



  }
  function renderPortfolio(){
    const el = document.getElementById('portfolioList'); el.innerHTML='';
    let totalPV=0;
   const now = Date.now();
state.portfolio.forEach((p,idx)=>{
  const remainingMs = p.maturityTime - now;
 const remainingMin = Math.max(0, Math.ceil(remainingMs / 60000));

      // present value estimate: simple: face * (price/100)
      const cost = (p.face/100)*p.pricePer100;
      // not discounting coupons — approximate
      totalPV += cost;
      const d = document.createElement('div'); d.className='bond';
      d.innerHTML = `<div>
  <div style='font-weight:700'>${p.id}</div>
  <div class='mini'>
    face ${p.face.toLocaleString()} | coupon ${p.couponRate}% | yield ${p.yield}% | remaining ${remainingMin} min
  </div>
</div>
<div style='text-align:right'>
  <div class='mini'>paid</div>
  <div style='font-weight:800'>${balanceFmt(cost)}</div>
</div>`;

      el.appendChild(d);
    });
    portfolioValueEl.textContent = balanceFmt(totalPV);
  }
  function renderHistory(){
  historyTableBody.innerHTML = '';
  state.auctionHistory.slice(0,30).forEach(row=>{
    const bond = row.bond;
    // Convert minutes to years (approx 525600 minutes per year)
    const maturityYears = bond.maturityMinutes ? (bond.maturityMinutes / 525600).toFixed(2) : bond.maturityYears || '-';
    
    const avgPriceDisplay = row.avgPrice === null ? '-' : '$' + row.avgPrice;
    const yieldDisplay = row.yield === null ? '-' : row.yield + '%';
    
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${new Date(row.time).toLocaleTimeString()}</td>
      <td>${bond.id}</td>
      <td>${maturityYears}</td>
      <td>${avgPriceDisplay}</td>
      <td>${yieldDisplay}</td>
      <td>${row.issued.toLocaleString()}</td>
    `;
    historyTableBody.appendChild(tr);
  });
}


function processMaturities(){
  const now = Date.now();
  let matured = [];

  state.portfolio = state.portfolio.filter(bond => {
    if(now >= bond.maturityTime){
      matured.push(bond);
      return false; // remove from portfolio
    }
    return true;
  });

  matured.forEach(bond => {
    // Face value repayment
    const faceValue = bond.face;

    // Simple interest payout:
    // couponRate is annual %, maturityYears applies fully
    const interest =
      bond.face * (bond.couponRate / 100) * bond.maturityYears;

    const payout = faceValue + interest;

    state.balance += payout;

    logEvent(
      `Bond ${bond.id} matured → paid ${balanceFmt(payout)} ` +
      `(face ${balanceFmt(faceValue)} + interest ${balanceFmt(interest)})`
    );
  });

  if(matured.length){
    renderBalance();
    renderPortfolio();
    saveState();
  }
}

  // -------------------------
  // Sync tick: align auctions to UTC cycle and open/close deterministically
  function syncTick(){
    const now = Date.now();
    const times = getAuctionTimes(now);

    // determine if auction should be open in this cycle
    if(now >= times.auctionStart && now < times.auctionEnd){
      // auction should be open for this cycle
      if(!state.currentAuction || (state.currentAuction.cycleStart !== times.cycleStart)){
        // start deterministic auction for this cycle
        state.currentAuction = null; // clear any leftover
        // set nextBondId deterministically if needed: keep using increasing nextBondId but deterministic bond uses cycleStart seed
        startNewAuction(times.cycleStart);
        // if there were bids persisted for this cycle, try to restore them (loadState already does this)
        simulateBotsDuringAuction();
      } else {
        // already running correct auction
      }
    } else {
      // Not within open-window
      // If auction just ended, ensure close is called once
      if(state.currentAuction && now >= state.currentAuction.endsAt){
        // close the auction deterministically
        closeAuction(state.currentAuction);
      }
      // ensure currentAuction cleared when appropriate
      if(state.currentAuction && now >= times.nextCycleStart){
        state.currentAuction = null;
      }
    }

    // Update auction timer UI every tick
    if(state.currentAuction){
      const remaining = Math.max(0, state.currentAuction.endsAt - now);
      const sec = Math.ceil(remaining/1000);
      const mm = Math.floor(sec/60); const ss = sec%60;
      auctionTimer.textContent = `${mm.toString().padStart(2,'0')}:${ss.toString().padStart(2,'0')}`;
      auctionPhaseEl.textContent = state.auctionPhase;
    } else {
      // show time until next cycle start
      const untilNext = Math.max(0, times.nextCycleStart - now);
      const sec = Math.ceil(untilNext/1000);
      const mm = Math.floor(sec/60); const ss = sec%60;
      auctionTimer.textContent = `Next in ${mm.toString().padStart(2,'0')}:${ss.toString().padStart(2,'0')}`;
      auctionPhaseEl.textContent = 'waiting';
      state.auctionPhase = 'waiting'; 
      }

    // check maturities each tick
    processMaturities();

    // periodically persist state (also autosave)
  }

  // UI timers (keeps previous behavior but ties into syncTick)
  function startUITimer(){
  if(state.auctionTimerHandle) clearInterval(state.auctionTimerHandle);

  state.auctionTimerHandle = setInterval(()=>{
    syncTick();
    renderAuctionBook();
    renderCurrentBond();
    renderPortfolio();
  }, 1000);
}


  // Reset game
  function resetGame(){
    if(!confirm('Reset the game? This will wipe your balance and portfolio.')) return;
    state.balance = 1_000_000;
    state.portfolio = [];
    state.nextBondId = 1;
    state.currentAuction = null;
    state.auctionHistory = [];
    state.auctionPhase = 'waiting';
    renderBalance(); renderPortfolio(); renderHistory(); auctionBookEl.innerHTML=''; currentBondEl.innerHTML=''; eventLog.innerHTML='';
    saveState();
    // schedule first auction shortly (UTC scheduler will start at next tick)
  }

  // Wire events
  placeBidBtn.addEventListener('click', ()=>placePlayerBid());
  clearBidsBtn.addEventListener('click', ()=>clearPlayerBids());
  resetBtn.addEventListener('click', ()=>resetGame());
  fastModeChk.addEventListener('change', ()=>{
    state.fastMode = fastModeChk.checked;
    // when fastMode toggled, update msPerGameYear behavior and auction timings (for local testing)
    if(state.fastMode){
    
    } else {  }
    logEvent('Fast Mode ' + (state.fastMode ? 'ENABLED' : 'DISABLED'));
    // save change to state
    saveState();
  });

  // -------------------------
  // Autosave every 2s and ensure initial load
  function autosaveLoop(){
    setInterval(()=>saveState(), 2000);
  }

  // Initialize
  function init(){
    loadState(); syncTick();   
    renderBalance(); renderPortfolio(); renderHistory(); startUITimer();
    autosaveLoop();
    // call syncTick immediately to align auctions
    syncTick();
    // schedule recurring: no setTimeout-based schedule required because syncTick will start auctions at UTC boundaries
  }
  init();

  // Expose saveState to console for debugging if needed
  window.BCT_save = saveState;
  window.BCT_load = loadState;

})();
</script>
</body>
</html>
