<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Secondary Market — Bond Auction Game</title>
  <style>
    /* Simple modern styling */
    :root{--bg:#0f1724;--card:#0b1220;--accent:#7dd3fc;--muted:#9ca3af;--glass: rgba(255,255,255,0.03)}
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,'Segoe UI',Roboto,'Helvetica Neue',Arial}
    body{background:linear-gradient(180deg,#071025 0%, #051027 60%);color:#e6eef8;padding:24px}
    .wrap{max-width:1200px;margin:0 auto}
    header{display:flex;align-items:center;justify-content:space-between;margin-bottom:18px}
    h1{font-size:20px;margin:0}
    .sub{color:var(--muted);font-size:13px}
    .grid{display:grid;grid-template-columns:380px 1fr;gap:18px}
    .card{background:var(--card);padding:14px;border-radius:12px;box-shadow:0 6px 30px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.02)}
    .small{font-size:13px;color:var(--muted)}
    .balance{font-weight:700;font-size:18px}
    .btn{background:linear-gradient(90deg,var(--accent),#60a5fa);border:none;padding:8px 12px;border-radius:8px;color:#012;cursor:pointer;font-weight:700}
    .mutebtn{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:6px 10px;border-radius:8px}
    .auction-timer{font-weight:800;font-size:18px}
    .list{margin-top:12px;display:flex;flex-direction:column;gap:10px}
    .bond{background:var(--glass);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);display:flex;justify-content:space-between;align-items:center}
    label{display:block;font-size:13px;margin-bottom:6px}
    input[type=number], input[type=text], select{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    .log{height:180px;overflow:auto;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
    table{width:100%;border-collapse:collapse}
    th,td{padding:6px;text-align:left;font-size:13px}
    th{color:var(--muted);font-weight:600}
    .mini{font-size:12px;color:var(--muted)}
    .controls{display:flex;gap:8px;align-items:center}
    .bots{display:flex;gap:8px;flex-wrap:wrap}
    .chip{padding:6px 8px;background:rgba(255,255,255,0.03);border-radius:999px;border:1px solid rgba(255,255,255,0.02);font-size:12px}
    footer{margin-top:14px;color:var(--muted);font-size:12px}
    .progress{height:8px;background:rgba(255,255,255,0.03);border-radius:999px;overflow:hidden}
    .progress > span{display:block;height:100%;background:linear-gradient(90deg,#22c55e,#7dd3fc)}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Secondary Market — Government Bond Auctions</h1>
        <div class="sub">Real-feel secondary market simulation — preset funds, live auctions, AI bidders, and maturities.</div>
      </div>
      <div class="controls">
        <div class="mini">Fast Mode (for testing):</div>
        <label style="display:flex;align-items:center;gap:8px"><input id="fastMode" type="checkbox"> seconds=minutes</label>
        <button id="resetBtn" class="mutebtn">Reset Game</button>
      </div>
    </header>

    <div class="grid">
      <aside class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div class="small">Player</div>
            <div class="balance" id="balanceDisplay">$1,000,000.00</div>
            <div class="small">Portfolio value: <span id="portfolioValue">$0.00</span></div>
          </div>
          <div style="text-align:right">
            <div class="small">Current Auction</div>
            <div class="auction-timer" id="auctionTimer">--:--</div>
            <div class="small">Phase: <span id="auctionPhase">Waiting</span></div>
          </div>
        </div>

        <hr style="border:none;height:1px;background:rgba(255,255,255,0.03);margin:12px 0">

        <div>
          <div class="small">Place Bid</div>
          <label>Bid price (per 100 face): <input id="bidPrice" type="number" step="0.01" value="99.50"></label>
          <label>Quantity (face value): <input id="bidQty" type="number" step="100" value="1000"></label>
          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="placeBidBtn" class="btn">Place Bid</button>
            <button id="clearBidsBtn" class="mutebtn">Clear My Bids</button>
          </div>
        </div>

        <hr style="border:none;height:1px;background:rgba(255,255,255,0.03);margin:12px 0">
        <div>
          <div class="small">Active Bonds (in portfolio)</div>
          <div id="portfolioList" class="list" style="max-height:220px;overflow:auto"></div>
        </div>

      </aside>

      <main>
        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div>
              <div style="font-weight:800">Live Auctions</div>
              <div class="mini">A new bond appears every 5 minutes — each auction lasts 3 minutes. Each auction issues a fixed total face amount and receives bids from you + AI robots. Average bid sets final price and yield.</div>
            </div>
            <div style="text-align:right">
              <div class="mini">Auction size (face): <strong id="auctionSize">100,000</strong></div>
              <div class="mini">Next auction starts on schedule</div>
            </div>
          </div>

          <hr style="border:none;height:1px;background:rgba(255,255,255,0.03);margin:12px 0">

          <div style="display:flex;gap:12px">
            <div style="flex:1">
              <div class="small">Current Bond</div>
              <div id="currentBond" style="margin-top:8px"></div>
            </div>
            <div style="width:320px">
              <div class="small">Auction Book</div>
              <div id="auctionBook" style="margin-top:8px;max-height:220px;overflow:auto"></div>
            </div>
          </div>

          <div style="margin-top:12px">
            <div class="small">Recent Events</div>
            <div id="eventLog" class="log"></div>
          </div>
        </div>

        <div style="height:12px"></div>

        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div><strong>Market History</strong> <div class="mini">Last auctions</div></div>
            <div class="mini">You cannot sell bonds; when maturity occurs you receive face + coupon proceeds.</div>
          </div>
          <div style="margin-top:8px">
            <table id="historyTable"><thead><tr><th>Time</th><th>Bond ID</th><th>Maturity (yrs)</th><th>Avg Price</th><th>Yield (%)</th><th>Qty Issued</th></tr></thead><tbody></tbody></table>
          </div>
        </div>

      </main>
    </div>

    <footer>
      Tip: Use <strong>Fast Mode</strong> to make "minutes" equal seconds for quick testing. Auctions still follow the 5-minute cycle but scaled down.
    </footer>
  </div>

<script>
/* Bond auction single-file game logic */
(function(){
  // --- Game state ---
  const state = {
    balance: 1_000_000, // player cash
    portfolio: [], // owned bonds
    nextBondId: 1,
    auctionCycleMs: 5 * 60 * 1000, // 5 minutes
    auctionDurationMs: 3 * 60 * 1000, // 3 minutes
    fastMode: false,
    auctionTimerHandle: null,
    auctionPhase: 'waiting',
    currentAuction: null,
    auctionHistory: []
  };

  // DOM
  const balanceDisplay = document.getElementById('balanceDisplay');
  const portfolioValueEl = document.getElementById('portfolioValue');
  const auctionTimer = document.getElementById('auctionTimer');
  const auctionPhaseEl = document.getElementById('auctionPhase');
  const currentBondEl = document.getElementById('currentBond');
  const auctionBookEl = document.getElementById('auctionBook');
  const eventLog = document.getElementById('eventLog');
  const historyTableBody = document.querySelector('#historyTable tbody');
  const balanceFmt = v => '$' + v.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});

  // Controls
  const bidPriceInput = document.getElementById('bidPrice');
  const bidQtyInput = document.getElementById('bidQty');
  const placeBidBtn = document.getElementById('placeBidBtn');
  const clearBidsBtn = document.getElementById('clearBidsBtn');
  const resetBtn = document.getElementById('resetBtn');
  const fastModeChk = document.getElementById('fastMode');
  const auctionSizeEl = document.getElementById('auctionSize');

  function logEvent(txt){
    const p = document.createElement('div'); p.textContent = `[${new Date().toLocaleTimeString()}] ${txt}`;
    eventLog.prepend(p);
  }

  // --- Bond generation ---
  function generateBond(){
    // Each bond has: id, couponRate (annual %), maturityMinutes, issuanceFace, description
    const id = state.nextBondId++;
    // Randomize coupon between 0.25% and 8% (annual)
    const coupon = +(Math.random() * 7.75 + 0.25).toFixed(3);
    // Randomize maturity between 1 year and 30 years, but in minutes notion for simulation
    // We'll pick maturity in years first
    const maturityYears = Math.floor(Math.random()*29)+1; // 1..29
    // In-game maturity minutes (for real-time maturity when scaled): choose days->minutes mapping
    const maturityMinutes = maturityYears * 60 * 24 * 365 / 60; // unrealistic; instead map 1 year -> 60 minutes for demo
    // We'll use 1 year = 60 minutes if fastMode, otherwise 1 year = 60*24*60 minutes — but to keep UI friendly, show years and also minutes to maturity
    // For allocation ease, issuance size:
    const issuance = 100_000; // face amount available in auction
    const bond = {
      id: `B-${String(id).padStart(4,'0')}`,
      couponRate: coupon, // annual %
      maturityYears: maturityYears,
      issuanceFace: issuance,
      description: `${maturityYears}-year Treasury-like bond @ ${coupon}% coupon`
    };
    return bond;
  }

  // --- Auction model ---
  function startNewAuction(){
    const bond = generateBond();
    state.currentAuction = {
      bond,
      bids: [], // {who:'player'|'botX', pricePer100, qtyFace}
      createdAt: Date.now(),
      startsAt: Date.now(),
      endsAt: Date.now() + state.auctionDurationMs
    };
    auctionSizeEl.textContent = bond.issuanceFace.toLocaleString();
    renderCurrentBond();
    renderAuctionBook();
    auctionPhaseEl.textContent = 'open';
    state.auctionPhase = 'open';
    logEvent(`Auction opened: ${bond.id} — ${bond.description}`);
    // schedule end
    setTimeout(() => closeAuction(state.currentAuction), state.auctionDurationMs);
  }

  function closeAuction(auction){
    if(!state.currentAuction || auction !== state.currentAuction) return;
    state.auctionPhase = 'settling';
    auctionPhaseEl.textContent = 'settling';
    // compute average price weighted by qty
    const bids = auction.bids;
    if(bids.length === 0){
      logEvent(`Auction ${auction.bond.id} closed with no bids — bond unsold.`);
      state.auctionHistory.unshift({time: new Date(), bond:auction.bond, avgPrice:null, yield:null, issued:0});
      renderHistory();
      state.currentAuction = null;
      // schedule next auction at cycle boundary
      scheduleNextAuction();
      return;
    }
    let totalNotional=0, weighted=0;
    bids.forEach(b=>{ totalNotional += b.qtyFace; weighted += b.qtyFace * b.pricePer100; });
    const avgPrice = +(weighted / totalNotional).toFixed(4); // per 100 face
    // compute simple annual yield approximation: (coupon + (100 - price)/yrs) / ((100+price)/2)
    const yrs = auction.bond.maturityYears;
    const coupon = auction.bond.couponRate;
    const yieldAnnual = +(((coupon + ((100 - avgPrice)/yrs)) / ((100+avgPrice)/2)) * 100).toFixed(4);
    // allocation: issuance divided proportionally across bidders
    const issuance = auction.bond.issuanceFace;
    const allocations = bids.map(b=>({who:b.who, qtyAllocated: Math.floor(b.qtyFace/100)})); // in lots of 100 face
    // total lots requested
    const totalLotsRequested = bids.reduce((s,b)=>s + Math.floor(b.qtyFace/100),0);
    const lotsToIssue = issuance/100;
    // determine allocations
    let resolved = [];
    if(totalLotsRequested <= 0){
      // no real requests
    }
    if(totalLotsRequested <= lotsToIssue){
      // everyone gets full
      bids.forEach(b=>{
        const lots = Math.floor(b.qtyFace/100);
        const assignedFace = lots*100;
        resolved.push({...b, assignedFace});
      });
    } else {
      // pro-rata by quantity
      bids.forEach(b=>{
        const lots = Math.floor(b.qtyFace/100);
        const fraction = lots/totalLotsRequested;
        const assignedLots = Math.floor(fraction * lotsToIssue);
        resolved.push({...b, assignedFace: assignedLots*100});
      });
      // If rounding left some lots, give them to highest price bids
      let allocatedLots = resolved.reduce((s,r)=>s + (r.assignedFace/100), 0);
      let remainingLots = lotsToIssue - allocatedLots;
      if(remainingLots>0){
        // sort by price desc
        const byPrice = resolved.slice().sort((a,b)=>b.pricePer100-a.pricePer100);
        for(let r of byPrice){ if(remainingLots<=0) break; r.assignedFace += 100; remainingLots--; }
      }
    }

    // settle: charge players and bots receive allocations (bots ignored). Player may have multiple bids; process any entries with who === 'player'
    const playerBids = resolved.filter(r=>r.who === 'player' && r.assignedFace>0);
    const playerTotalAssigned = playerBids.reduce((s,r)=>s + r.assignedFace,0);
    const playerCost = playerTotalAssigned/100 * avgPrice; // per 100 face
    // convert to actual dollars: price per 100 face times number of lots (face/100)
    const playerCostDollars = playerCost * 1; // since price is per 100 face representing dollars per 100 face
    // But to make units consistent: We interpret pricePer100 as dollars per 100 face. So cost = (assignedFace/100)*pricePer100
    let actualPlayerCost = 0;
    playerBids.forEach(b=>{ actualPlayerCost += (b.assignedFace/100) * avgPrice; });

    // Deduct from balance and add portfolio entries
    if(actualPlayerCost>0){
      if(actualPlayerCost > state.balance){
        // can't pay: reduce allocation to zero and log
        logEvent(`Player allocation for ${auction.bond.id} exceeded balance — allocation canceled.`);
      } else {
        state.balance -= actualPlayerCost;
        // add bond to portfolio as a position with assignedFace and purchase price
        const pos = {
          id: auction.bond.id,
          couponRate: auction.bond.couponRate,
          maturityYears: auction.bond.maturityYears,
          face: playerTotalAssigned,
          pricePer100: avgPrice,
          purchaseTime: new Date(),
          yield: yieldAnnual
        };
        state.portfolio.push(pos);
        logEvent(`Auction ${auction.bond.id} settled: avgPrice=$${avgPrice} | yield=${yieldAnnual}% | you received ${playerTotalAssigned.toLocaleString()} face for $${actualPlayerCost.toFixed(2)}`);
      }
    } else {
      logEvent(`Auction ${auction.bond.id} settled: avgPrice=$${avgPrice} | yield=${yieldAnnual}% | you did not receive allocation.`);
    }

    // record to history
    state.auctionHistory.unshift({time: new Date(), bond:auction.bond, avgPrice, yield: yieldAnnual, issued: issuance});
    renderHistory();
    renderPortfolio();
    renderBalance();

    // cleanup
    state.currentAuction = null;
    scheduleNextAuction();
  }

  // schedule next auction to start at the next cycle boundary: auctions every 5 minutes
  function scheduleNextAuction(){
    // For simplicity: start a new auction after (auctionCycleMs - auctionDurationMs) from now.
    const gap = Math.max(1000, state.auctionCycleMs - state.auctionDurationMs);
    setTimeout(()=>{
      // Simulate bots placing some preliminary bids for the new auction
      startNewAuction();
      // let bots bid periodically during the open auction
      simulateBotsDuringAuction();
    }, gap);
  }

  // --- Bots ---
  const botNames = ['AlphaBot','BetaBot','GammaBot','DeltaBot','Epsilon'];
  function simulateBotsDuringAuction(){
    if(!state.currentAuction) return;
    const auction = state.currentAuction;
    // every 5-15 seconds (or scaled) bots place bids
    const intervalMs = state.fastMode ? 1500 : 8000;
    const rounds = state.fastMode ? 6 : Math.max(8, Math.floor(state.auctionDurationMs/intervalMs));
    for(let i=0;i<rounds;i++){
      setTimeout(()=>{
        if(!state.currentAuction || state.currentAuction !== auction) return;
        // each round, a few random bots bid
        const n = Math.floor(Math.random()*3)+1;
        for(let j=0;j<n;j++){
          const bot = botNames[Math.floor(Math.random()*botNames.length)];
          // bot chooses price around a range depending on coupon: aim near 100
          const coupon = auction.bond.couponRate;
          const base = 100 - (coupon - 2) + (Math.random()*2 -1) * 2.5; // roughness
          const price = +(base + (Math.random()*4 - 2)).toFixed(4);
          const qty = (Math.floor(Math.random()*40)+1)*100; // lots of 100
          auction.bids.push({who:bot, pricePer100:price, qtyFace:qty});
        }
        renderAuctionBook();
      }, i*intervalMs + Math.random()*1000);
    }
  }

  // Player interactions
  function placePlayerBid(){
    if(!state.currentAuction){ alert('No active auction.'); return; }
    const price = parseFloat(bidPriceInput.value);
    const qty = parseInt(bidQtyInput.value);
    if(isNaN(price) || isNaN(qty) || price<=0 || qty<=0){ alert('Enter valid bid and quantity.'); return; }
    // store bid
    state.currentAuction.bids.push({who:'player', pricePer100:+price, qtyFace:qty});
    logEvent(`You placed bid: $${price.toFixed(2)} per 100 | qty ${qty.toLocaleString()}`);
    renderAuctionBook();
  }

  function clearPlayerBids(){
    if(!state.currentAuction) return;
    state.currentAuction.bids = state.currentAuction.bids.filter(b=>b.who !== 'player');
    logEvent('Cleared your bids for current auction.');
    renderAuctionBook();
  }

  // Rendering functions
  function renderBalance(){ balanceDisplay.textContent = balanceFmt(state.balance); }
  function renderAuctionBook(){
    auctionBookEl.innerHTML = '';
    if(!state.currentAuction){ auctionBookEl.textContent = 'No active auction.'; return; }
    const grouped = {};
    state.currentAuction.bids.slice().reverse().forEach(b=>{
      const div = document.createElement('div'); div.className='bond';
      div.innerHTML = `<div style="flex:1"><div style='font-weight:700'>${b.who}</div><div class='mini'>qty ${b.qtyFace.toLocaleString()} face</div></div><div style='text-align:right'><div style='font-weight:800'>$${b.pricePer100}</div></div>`;
      auctionBookEl.appendChild(div);
    });
  }
  function renderCurrentBond(){
    currentBondEl.innerHTML = '';
    if(!state.currentAuction){ currentBondEl.textContent = 'No live bond right now. An auction will open on schedule.'; return; }
    const b = state.currentAuction.bond;
    const box = document.createElement('div'); box.className='bond';
    box.innerHTML = `<div style='flex:1'><div style='font-weight:800'>${b.id} — ${b.couponRate}% coupon</div><div class='mini'>${b.description}</div><div class='mini'>Maturity: ${b.maturityYears} years</div></div><div style='text-align:right'><div class='mini'>Issuance</div><div style='font-weight:800'>${b.issuanceFace.toLocaleString()} face</div></div>`;
    currentBondEl.appendChild(box);
  }
  function renderPortfolio(){
    const el = document.getElementById('portfolioList'); el.innerHTML='';
    let totalPV=0;
    state.portfolio.forEach((p,idx)=>{
      // present value estimate: simple: face * (price/100)
      const cost = (p.face/100)*p.pricePer100;
      // not discounting coupons — approximate
      totalPV += cost;
      const d = document.createElement('div'); d.className='bond';
      d.innerHTML = `<div><div style='font-weight:700'>${p.id}</div><div class='mini'>face ${p.face.toLocaleString()} | coupon ${p.couponRate}% | yield ${p.yield}%</div></div><div style='text-align:right'><div class='mini'>paid</div><div style='font-weight:800'>${balanceFmt(cost)}</div></div>`;
      el.appendChild(d);
    });
    portfolioValueEl.textContent = balanceFmt(totalPV);
  }
  function renderHistory(){
    historyTableBody.innerHTML = '';
    state.auctionHistory.slice(0,30).forEach(row=>{
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${row.time.toLocaleTimeString()}</td><td>${row.bond.id}</td><td>${row.bond.maturityYears}</td><td>${row.avgPrice===null?'-':('$'+row.avgPrice)}</td><td>${row.yield===null?'-':row.yield+'%'}</td><td>${row.issued.toLocaleString()}</td>`;
      historyTableBody.appendChild(tr);
    });
  }

  // UI timers
  function startUITimer(){
    if(state.auctionTimerHandle) clearInterval(state.auctionTimerHandle);
    state.auctionTimerHandle = setInterval(()=>{
      // update auction timer and phase
      if(state.currentAuction){
        const now = Date.now();
        const remaining = Math.max(0, state.currentAuction.endsAt - now);
        const sec = Math.ceil(remaining/1000);
        const mm = Math.floor(sec/60); const ss = sec%60;
        auctionTimer.textContent = `${mm.toString().padStart(2,'0')}:${ss.toString().padStart(2,'0')}`;
      } else {
        auctionTimer.textContent = '--:--';
        auctionPhaseEl.textContent = 'waiting';
      }
    }, 500);
  }

  // Reset game
  function resetGame(){
    if(!confirm('Reset the game? This will wipe your balance and portfolio.')) return;
    state.balance = 1_000_000;
    state.portfolio = [];
    state.nextBondId = 1;
    state.currentAuction = null;
    state.auctionHistory = [];
    state.auctionPhase = 'waiting';
    renderBalance(); renderPortfolio(); renderHistory(); auctionBookEl.innerHTML=''; currentBondEl.innerHTML=''; eventLog.innerHTML='';
    // schedule first auction shortly
    setTimeout(()=>{ startNewAuction(); simulateBotsDuringAuction(); }, 1000);
  }

  // Wire events
  placeBidBtn.addEventListener('click', ()=>placePlayerBid());
  clearBidsBtn.addEventListener('click', ()=>clearPlayerBids());
  resetBtn.addEventListener('click', ()=>resetGame());
  fastModeChk.addEventListener('change', ()=>{
    state.fastMode = fastModeChk.checked;
    if(state.fastMode){
      state.auctionCycleMs = 5 * 1000; state.auctionDurationMs = 3 * 1000;
    } else { state.auctionCycleMs = 5*60*1000; state.auctionDurationMs = 3*60*1000; }
    logEvent('Fast Mode ' + (state.fastMode ? 'ENABLED' : 'DISABLED'));
  });

  // Initialize
  function init(){
    renderBalance(); renderPortfolio(); renderHistory(); startUITimer();
    // start first auction in 2 seconds
    setTimeout(()=>{ startNewAuction(); simulateBotsDuringAuction(); }, 1200);
    // schedule recurring auctions: every auctionCycleMs (startNewAuction called after each closure)
  }
  init();
})();
</script>
</body>
</html>
